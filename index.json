[{"categories":null,"content":"技巧\r\r本篇记录阅读项目中发现的工具包使用方法\r\r ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:0:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"basic while name = str(\"some\") names = [Str(),Str()] while name in names: name = name+\"_\" split() 和 rsplit() # split() # return [list] ,使用seq作为分割字符串（默认' ' and '\\n'），maxsplit为最大分割次数 str.split(sep=None, maxsplit=-1) # rsplit() # 与split相似，分割从右侧开始 str.rsplit(sep=None, maxsplit=-1) ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:1:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"os 使用 os.path.dirname 替代切换至上级目录../ from os.path import dirname BASE_DIR = dirname(abspath(__file__)) ROOT_DIR = dirname(BASE_DIR) sys.path.append(BASE_DIR) sys.path.append(ROOT_DIR) os.path.join(*List(PATH)) 路径拼接 win32与linux使用不同的分隔符，可使用 .replace() 替换后再使用 .split() 分割 注意：多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.basename 返回文件名 \u003e\u003e\u003e os.path.basename(r'c:\\test.csv') 'test.csv' \u003e\u003e\u003e os.path.basename('c:\\csv') 'csv' （这里csv被当作文件名处理了） \u003e\u003e\u003e os.path.basename('c:\\csv\\') '' 用户路径名 os.path.expanduser(dst) ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:2:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"pathlib pathlib.Path(path) from pathlib import Path source_path = \"\" file = Path(source_paht) file.parent file.touch() # 创建 file.unlink() # 删除 file.relative_to(dir_1) # file 相对于dir_1的位置 #or files = Path(file).glob(\"*.txt\") # 分级查找：*第一级 */* 第二级 files = Paht(flie).rglob(\"*.mp4\") # 递归查找 for f in files: print(f) # 路径解码 -\u003e windows路径分隔符更改，更换为绝对路径 file = Path().resolve() # 将~替换为用户家目录 ,~user替换为user的家目录 Path().expanduser() ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:3:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"glob glob.glob() 返回所有匹配的文件路径列表 img_path = sorted(glob.glob(os.path.join(images,\"*.jpg\"))) ”*”匹配0个或多个字符； ”?”匹配单个字符； ”[]”匹配指定范围内的字符，如：[0-9]匹配数字。 ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:4:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"numpy 数组拼接 np.concatenate(arrays, axis=i) e.g. i记为可滑动第i维索引 arr = [] for subarr in iterator: arr.append(subarr) outarr = np.concatenate(arr,0) 随机选取 choices = np.random.choice(A,i) # A必须为一维数组 1—D choices = A[np.random.choice(A.shape[0],i),:] # A为高维数组 choices = random.choice(A) # A维度不作要求 维度增加 np.newaxis == None img[np.newaxis, :, :] # -\u003e 1,w,h ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:5:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"collections 双向队列 from collections import deque 有序集合 from collections import OrderedDict ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:6:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"cv2 注意\r\r​ opencv中的颜色读取默认为BGR通道\r\r 视频文件切换至指定帧 # 视频流信息（文件）读取 capture = cv2.VideoCapture(os.path.join(videoPath, video)) # 读取FPS fps = int(capture.get(cv2.CAP_PROP_FPS)) # 设置将读取的帧数｛count｝，而后读取即可 capture.set(cv2.CAP_PROP_POS_FRAMES,count) ret, img = capture.read() 仿射变换与透视变换 # 获得仿射变换矩阵M，由对应点获得(都需转换为np.float32) src_point = np.array([],dtype=np.float32) src_point = np.float32([[],]) src_point = np.random.random((3,2)).asdtype(np.float32) dst_point = np.float([[],]) # 仿射变换满足平直性和平行性 M = cv2.getAffineTransform(src_point,dst_point) M = cv2.getPerspectiveTransform(src_point,dst_point) # 图像变换使用warp*,对索引做映射 outImg = cv2.warpAffine(inImg,M,(w,h)) #仿射变换 outImg = cv2.warpPerspective(inImg,M,(w,h)) #透视变换 # 点集的变换使用perspectiveTransform映射,对值做映射 points = points.reshape(1, -1, 2).astype(np.float32) out_point = cv2.perspectiveTransform(points, M).astype(np.int32).reshape(-1,2) 仿射变换估计 a, b = np.array(),np.array() # fullAffine 六自由度仿射变换,至少需要3个点,多余的点使用最小二乘法拟合 # 尺度、旋转、位移、斜切 # [[a b c] # [d e f]] m = cv2.estimateAffine2D(a, b) # partialAffine 四自由度仿射变换,至少需要2个点 # 尺度、旋转、位移 # [[cos*s -sin*s tx] # [sin*s cos*s ty]] m = cv2.estimateAffinePartial2D(a, b) URL:https://blog.csdn.net/dongfang1984/article/details/52959308 特征点匹配与映射 def sift_detect(srcImg, dstImg, detector='sift', matcher ='FLANN'): # 查找关键点 if detector.startswith('si'): print(\"sift detector......\") detector = cv2.SIFT_create() else: print(\"ORB detector......\") detector = cv2.ORB_create() kp1, des1 = detector.detectAndCompute(srcImg, None) kp2, des2 = detector.detectAndCompute(dstImg, None) # kp1 返回类型为[cv2.KeyPoint,···] # KeyPoint.pt 关键点位置坐标 # KeyPoint.size 关键点邻域直径 # KeyPoint.angle 特征点的方向，值为[零, 三百六十)，负值表示不使用 # KeyPoint.response KeyPoint.octave特征点所在的图像金字塔的组 KeyPoint.class_id 用于聚类的id # 关键点匹配 if matcher.startswith('BFM'): bf = cv2.BFMatcher() matches = bf.knnMatch(des1, des2, k=2) #k=2为查找前两个相似点 else: FLANN_INDEX_KDTREE = 0 indexParams = dict(algorithm=FLANN_INDEX_KDTREE, tree=5) searchParams = dict(checks=100) # 指定索引树被遍历多少次，次数越多，计算时间越长，越精确 flann = cv2.FlannBasedMatcher(indexParams, searchParams) matches = flann.knnMatch(des1, des2, k=2) #k=2为查找前两个相似点 # matches 返回类型为[cv2.DMatch,···] # • DMatch.distance - 描述符之间的距离。越小越好。 # • DMatch.trainIdx - 目标图像中描述符的索引。 # • DMatch.queryIdx - 查询图像中描述符的索引。 # • DMatch.imgIdx - 目标图像的索引。 # 若最相似点的相似距离 小于 次相似点相似距离的0.5倍，则认为相似 good = [m for m, n in matches if m.distance \u003c 0.5 * n.distance] min_match_count = 5 if len(good) \u003e min_match_count: # 匹配点 src_pts = np.float32([kp1[m.queryIdx].pt for m in good]).reshape(-1, 1, 2) dst_pts = np.float32([kp2[m.trainIdx].pt for m in good]).reshape(-1, 1, 2) # 找到变换矩阵m m, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5, 0) #return 3*3 matchmask = mask.ravel().tolist() 图像变换 # 注意交换坐标位置 h, w = image_mask.shape[:2] image = cv.resize(image, (w, h), interpolation=cv.INTER_LINEAR) 圆形绘制 # 被绘制图像img | 点坐标w,h |半径:radius | 填充像素 | 线宽 -1为内部填充 cv.circle(img, (point[1], point[0]), radius, (0), -1) ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:7:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"logging 日志文件配置 https://blog.csdn.net/pansaky/article/details/90710751 ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:8:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"multiprocessing 设置守护进程 [setattr(process, \"daemon\", True) for process in processes] ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:9:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"pandas 筛选 筛选指定行 data = df.loc[2:5] 筛选出数据某列为某值的所有数据记录 data = df[(df['列名1']== ‘列值1’)] # 多条件匹配时，使用 \u0026|等符号连接各个条件 # 注意：使用()包围各个条件 data_many=df[(df['列名1']== ‘列值1’)\u0026(df['列名2']==‘列值2’)] # 多值匹配时 条件取反可使用==False 和 ~ data = data[~data[\"label\"].str.contains('falling|squat')] str.startswith data = data[~data[\"NodeId\"].isin ([\"fe50c54a-5091-4fb2-8487-efeffd10592d\",\"fcc671c2-c92c-4285-934f-dda38a2ed475\"])] 模式匹配 # 开头包含某值的模式匹配 cond=df['列名'].str.startswith('值') # 中间包含某值的模式匹配,可添加正则表达式 cond=df['列名'].str.contains('apple|banana') 数字值筛选 data = flags[(flags['num']\u003e=1) | (flags['bars']\u003e=1)] 参考： [https://blog.csdn.net/weixin_42322206/article/details/123607271](https://) 表格编辑 列表头替换 dt = pd.DataFrame() dt.columns = ['a','b','c'] # 缺点为必须与源表头数目对应 dt.rename(columns={'A':'a','C':'c'}, inplace = True) #源表头与目标表头映射 ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:10:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"einops 与enisum函数相似，但enisum从索引的角度出发计算 一个或两个矩阵 的计算法则，但einops更应该应用在 单个矩阵 的变换。 rearrange() 维数变换 images = rearrange(imgs, \"(b1 b2) h w c -\u003e (b1 h) (b2 w) c\",b1 = 3) reduce() 维数减少可用于min、max、mean reduce(obj, \"(h h_s) (w w_s) c -\u003e h w c\", reduction=\"max\", h_s=step, w_s=step) # 'b h w c -\u003e b () () c' 等价于 'b h w c -\u003e b 1 1 c' repeat() 使用重复的方法增加维数 repeat(obj, \"h w c -\u003e (h h_s) (w w_s) c\", h_s=step, w_s=step) parse_shape() 解析张量形状，将轴名称映射到其长度。 x = np.zeros([2, 3, 5, 7]) parse_shape(x, 'batch _ h w') {'batch': 2, 'h': 5, 'w': 7} y = np.zeros([700]) rearrange(y, '(b c h w) -\u003e b c h w', **parse_shape(x, 'b _ h w')).shape (2, 10, 5, 7) https://zhuanlan.zhihu.com/p/372692913 https://github.com/arogozhnikov/einops/blob/master/docs/1-einops-basics.ipynb ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:11:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"Albumentations (图像数据增强) 加载 import albumentations as A import cv2 image = cv2.imread(\"/path/to/image.jpg\") image = cv2.cvtColor(image,cv2.COLOR_BGR2RGB) # cv2默认读取BGR格式，Albumentations使用RGB格式 管道组合 Compose ,单图像增强 transform = A.Compose([ A.RandomCrop(width=256, height=256), A.HorizontalFlip(p=0.5), A.RandomBrightnessContrast(p=0.2), ]) transformed = transform(image = image) #內键为\"image\" transformed_image = transformed[\"image\"] 图像 蒙版增强 mask = cv2.imread(\"/path/to/mask.png\") transformed = transform(image = image, mask=mask) #內键为\"image\" transformed_image = transformed[\"image\"] transformed_mask = transformed['mask'] # masks = [mask1,mask2,···] 多蒙版模式 transformed = transform(image=image, masks=masks) 图像 包围框增强 transform = A.Compose([ A.RandomCrop(width=450, height=450), A.HorizontalFlip(p=0.5), A.RandomBrightnessContrast(p=0.2), ], bbox_params=A.BboxParams(format='coco', min_area=1024, min_visibility=0.1, label_fields=['class_labels'])) # class_labels与定义时label_fields对应 transformed = transform(image=image, bboxes=bboxes, class_labels=class_labels) transformed_image = transformed['image'] transformed_bboxes = transformed['bboxes'] transformed_class_labels = transformed['class_labels'] 图像 关键点 增强 transform = A.Compose([ A.RandomCrop(width=330, height=330), A.RandomBrightnessContrast(p=0.2), ], keypoint_params=A.KeypointParams(format='xy', label_fields=['class_labels'], remove_invisible=True, angle_in_degrees=True)) transformed = transform(image=image, keypoints=keypoints) transformed_image = transformed['image'] transformed_keypoints = transformed['keypoints'] 图像 包围框 关键点 增强 pass https://blog.csdn.net/weixin_36670529/article/details/116626394 ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:12:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"natsort 自然排序 natsorted（本质套皮sorted，整合key） from natsort import natsorted,ns # ns 为自然排序方法标志 # eg: ns.REAL = ns.FLOAT | ns.SIGNED 解析参数为有符号浮点数 # eg：ns.PATH ret = natsorted(a, alg=ns.REAL | ns.LOCALE | ns.IGNORECASE) ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:13:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"tensorboard https://zhuanlan.zhihu.com/p/484289017 ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:14:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"ffmpeg ffmpy3 安装 pip install ffmpy3 使用 from ffmpy3 import FFmpeg ff = FFmpeg(inputs={str(input_filename): ['-ss', '{float}', '-to', '{float}']}, outputs={str(output_filename): ['-c:v', 'libx264', '-loglevel', 'panic']}) print(ff.cmd) # 打印ffmpeg命令 ff.run() # 同步运行 ff.run_async() # 异步运行 await ff.wait() ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:15:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"pytorch-GAM ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:16:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"Kornia ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:17:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"matplotlib 查看可用字体 from matplotlib.font_manager import FontProperties,fontManager mpl_fonts = set(f.name for f in FontManager().ttflist) print('all font list get from matplotlib.font_manager:') for f in sorted(mpl_fonts): print('\\t' + f) 设置字体 import matplotlib.pyplot as plt import matplotlib matplotlib.rc(\"font\", family='Microsoft YaHei') #本地临时加载 fontManager.addfont('myscript/simhei.ttf') # my_font = FontProperties(fname=r\"./simhei.ttf\", size=12) matplotlib.rc(\"font\", family='simhei') ","date":"2022-03-31","objectID":"/python-%E5%87%BD%E6%95%B0/:18:0","tags":null,"title":"Python函数记录","uri":"/python-%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"this is before 本地资源引用\r\r 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! \r\r KaTeX在编写中出现乱码情况，标签应为下列之一：aligned, array, gathered, matrix。equation等式标签经测试渲染失效。 \\begin{aligned} \"\\cr\" \\end{aligned} https://zhuanlan.zhihu.com/p/168773798 ","date":"2022-03-31","objectID":"/%E6%B5%8B%E8%AF%95/:0:0","tags":null,"title":"test","uri":"/%E6%B5%8B%E8%AF%95/"},{"categories":["Math"],"content":"形式二：为证明$f(a+b)=f(a)*f(b)$存在唯一实数解$f(x)=a^x$ ","date":"2022-03-16","objectID":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/:0:0","tags":null,"title":"柯西方程与柯西方法","uri":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/"},{"categories":["Math"],"content":"证明 设n为正整数，则 $$ \\begin{aligned} \u0026f(n+1)=f(n)*f(1) \\cr f(n)\u0026=f(n-1)*f(1)\\cr \u0026=f(n-2)*f(1)^2 \\cr \u0026=\\cdots \\cr \u0026=f(1)^n \\end{aligned} $$ 所以 正整数 成立。 由题干性质 $ f(0+0)=f(0)*f(0) $ 可知，$f(0)= 1 \\ or \\ 0$ ，显然为0时，整个函数为0常函数，结论平凡。以下默认$f(0)=1$ . 所以 $$ \\begin{gathered} f(0)=f(n+(-n))=f(n)*f(-n) \\cr f(-n)=f(n)^{-1}=f(1)^{-n} \\end{gathered} $$ 即对 整数 成立。 设n,m为整数 $$ \\begin{aligned} f(n)\u0026=f(\\underbrace { \\frac{1}{n}+\\frac{1}{n}+, \\cdots, + \\frac{1} {n} }_{n^2}) \\cr \u0026=f(\\frac{1}{n})^{n^2} \\end{aligned} $$ 所以 $$ \\begin{aligned} f(\\frac{1}{n})=f(n)^{\\frac{1}{n^2}}=[f(1)^n]^{\\frac{1} {n^2}}=f(1)^{\\frac{1}{n}} \\end{aligned} $$ 则 $$ \\begin{aligned} f(\\frac{m}{n})=f(\\underbrace { \\frac{1}{n} + \\frac{1}{n} + ,\\cdots , + \\frac{1}{n} }_{m})=f(\\frac{1}{n})^m=f(1)^{\\frac{m}{n}} \\end{aligned} $$ 任意有理数可表示为$\\frac{m}{n}$ 的形式，可知结果对 有理数 成立。 如满足下列条件其一 f 连续； f 在一个区间上单调； f 在一个区间上有上界或下界。 易证以上结论在 实数域 上成立。 ","date":"2022-03-16","objectID":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/:0:1","tags":null,"title":"柯西方程与柯西方法","uri":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/"},{"categories":["Math"],"content":"结论 综上，$f(a+b)=f(a)*f(b)$存在唯一实数解$f(x)=a^x$ 参考：https://zhuanlan.zhihu.com/p/80543711 $$ \\begin{aligned} –1– \\end{aligned} $$ ","date":"2022-03-16","objectID":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/:0:2","tags":null,"title":"柯西方程与柯西方法","uri":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/"},{"categories":["Math"],"content":"协方差矩阵对角化 设一点集 $$ D= \\left[\\begin{matrix} x_1,y_1 \\cr x_2,y_2\\cr …\\cr x_n,y_n \\end{matrix}\\right]^T $$ 协方差公式为： $$ \\begin{aligned} cov(x,y)=\\frac{ \\sum_i^n{(x_i-\\bar x)(y_i-\\bar y)}}{n-1} \\end{aligned} $$ 去中心化后$\\bar x,\\bar y$为0，（1）式可化为 $$ \\begin{gathered} cov(x,y)=\\frac{ \\sum_i^n{x_iy_i}}{n-1} \\end{gathered} $$ 协方差矩阵为 $$ C = \\left(\\begin{matrix} cov(x,x)\u0026cov(x,y)\\cr cov(y,x)\u0026cov(y,y) \\end{matrix}\\right) $$ $$C = \\frac{1}{n-1}\\cdot DD^T$$ $D$为原始数据分布，$D_s$为 PCA 后其对应的分布，则存在旋转（R）、拉伸（S）矩阵，使得$D=RSD_s$,其中 $$ R=\\left(\\begin{matrix} cos(\\theta)\u0026-sin(\\theta) \\cr sin(\\theta)\u0026cos(\\theta) \\end{matrix}\\right), S=\\left(\\begin{matrix} a\u0026\\cr \u0026b \\end{matrix}\\right) $$ 所以 $$ \\begin{aligned} C^`\u0026=\\frac{1}{n-1} \\cdot DD^{T}= \\frac{1}{n-1}\\cdot RSD_s \\cdot (RSD_s)^T \\cr \u0026=RS\\cdot (\\frac{1}{n-1}D_sD_s^T)\\cdot S^TR^T \\cr \u0026=RSC_sS^TR^T=RSS^TR^T \\cr \u0026=RLR^T \\cr \\end{aligned} $$ 其中 $$ R= \\left( \\begin{matrix} cos(\\theta) \u0026 -sin(\\theta) \\cr sin(\\theta) \u0026 cos(\\theta) \\end{matrix} \\right), L= \\left(\\begin{matrix} a^2 \u0026 \\cr \u0026 b^2 \\end{matrix}\\right) $$ 可见L矩阵为对角阵，R矩阵为正交矩阵$R\\cdot R^T=E$,求R与L相当于对 协方差矩阵对角化。 import numpy as np data = np.random.rand(10,2) #二维点集 n*d cov = np.cov(data.T) #d*d w, v = np.linalg.eig(cov) #此处对特征向量做了单位化，即列向量模长为1 #cov = v@np.diag(w)@v.T indiex = np.argsort(-w) v = v[:,indiex] w = w[indiex] 正交化证明1 $$ \\begin{aligned} MM^T \u0026= v * w * v^{-1} \\cr MM^T \u0026= v^{-T} * w * v^T \\cr v^{-T} * w * v^T \u0026= v * w * v^{-1} \\cr w * v^T * v \u0026= v^T * v * w \\cr w * N \u0026= N * w \\cr a * N[:,0] \u0026= N[0,:] * a \\cr \\end{aligned} $$ 所以N只有对角元素上有值，即特征向量两两正交。但v不一定是酉矩阵，因为没做单位化。而numpy的算法做了单位化处理，具有特异性。 正交化证明2 n维实对称矩阵S，用$\\lambda ,\\alpha$表示其两个不等的特征值，用$x,y$分别表示其对应的特征向量。$S=S^T,Sx=\\lambda x,Sy=\\alpha y(\\alpha \\neq \\lambda)$. 对$Sx=\\lambda x$两边转置右端乘$y$ $$ \\begin{aligned} x^TS^T \u0026= \\lambda x^T\\cr x^TS \u0026= \\lambda x^T\\cr x^TSy \u0026= \\lambda x^Ty \\end{aligned} $$ 对$Sy=\\alpha y$两段左乘$x^T$ $$x^TSy=x^T\\alpha y=\\alpha x^Ty$$ 所以 $$ \\begin{aligned} \\alpha x^Ty \u0026=\\lambda x^Ty \\cr 0 \u0026=(\\alpha-\\lambda)x^Ty \\end{aligned} $$ 已知$\\alpha \\neq \\lambda$,所以$x^Ty=0$,即不同特征值的特征向量两两正交. ","date":"2022-03-09","objectID":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/:0:1","tags":null,"title":"主成分分析","uri":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":["Math"],"content":"PCA投影 维度，k为特征值占比85%的索引数 $D^T: n * d, C: d * d, v: d * d, u: d * k$（v是特征向量矩阵，u包含了特征向量对应特征值占比为前85%的列索引） 投影，$u$的每一列是单位化后的方向向量$|u_{*j}|=1$，点积相当于cos投影： 对D任意一行与u任意一列： $$ \\vec D^T_{i*} \\cdot \\vec u_{j}=|D^T_{i}|\\cdot |u_{j}| \\cdot cos(\\theta)=|D^T_{i}|\\cdot cos(\\theta)(投影值) $$ $D^T \\cdot u:n*k$ $s^2=\\frac{\\sum x_i^2}{n-1}=\\frac{u^TDD^Tu}{n-1}=u^TCu=\\lambda$ 证明如公式3，PCA后的方差是矩阵特征值。方差越大，数据含有的信息越多，数据信号越强 k = 1 Q = v[:,:k] data_norm = data - data.mean(0) # normalization Y = np.matmul(data_norm,Q) #n*d @ d*k = n*k data_ = np.matmul(Y,Q.T)+data.mean(0) # n*k @ k*d = n * d # plt.scatter(data_[:,0],data_[:,1]) ","date":"2022-03-09","objectID":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/:0:2","tags":null,"title":"主成分分析","uri":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":["Math"],"content":"OBB包围盒 todo ","date":"2022-03-09","objectID":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/:0:3","tags":null,"title":"主成分分析","uri":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":null,"content":"引言 语义分割是像素级别的分类，其常用评价指标： 像素准确率（Pixel Accuracy，PA）、 类别像素准确率（Class Pixel Accuray，CPA）、 类别平均像素准确率（Mean Pixel Accuracy，MPA）、 交并比（Intersection over Union，IoU）、 平均交并比（Mean Intersection over Union，MIoU）， 其计算都是建立在混淆矩阵（Confusion Matrix）的基础上。因此，了解基本的混淆矩阵知识对理解上述5个常用评价指标是很有益处的！ ","date":"2022-03-08","objectID":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:0:1","tags":null,"title":"语义分割评价指标","uri":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"},{"categories":null,"content":"评价指标 PA：像素准确率 对应：准确率（Accuracy） 含义：预测类别正确的像素数占总像素数的比例 混淆矩阵计算： 对角线元素之和 / 矩阵所有元素之和 PA = (TP + TN) / (TP + TN + FP + FN) CPA：类别像素准确率 对应：精准率（Precision） 含义：在类别 i 的预测值中，真实属于 i 类的像素准确率，换言之：模型对类别 i 的预测值有很多，其中有对有错，预测对的值占预测总值的比例 混淆矩阵计算： 类1：P1 = TP / (TP + FP) 类2：P2 = TN / (TN + FN) 类3：… MPA：类别平均像素准确率 含义：分别计算每个类被正确分类像素数的比例，即：CPA，然后累加求平均 混淆矩阵计算： 每个类别像素准确率为：Pi（计算：对角线值 / 对应列的像素总数） MPA = sum(Pi) / 类别数 IoU：交并比 含义：模型对某一类别预测结果和真实值的交集与并集的比值 混淆矩阵计算： 以求二分类：正例（类别1）的IoU为例 交集：TP，并集：TP、FP、FN求和 IoU = TP / (TP + FP + FN) MIoU：平均交并比 含义：模型对每一类预测的结果和真实值的交集与并集的比值，求和再平均的结果 混淆矩阵计算： 以求二分类的MIoU为例 MIoU = (IoU正例p + IoU反例n) / 2 = [ TP / (TP + FP + FN) + TN / (TN + FN + FP) ] / 2 ","date":"2022-03-08","objectID":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:0:2","tags":null,"title":"语义分割评价指标","uri":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"},{"categories":null,"content":"数值计算 计算混淆矩阵 def get_confusion_matrix(scores, labels): \"\"\"Computes the confusion matrix of one batch Args: scores (torch.FloatTensor, shape (B?, N, C): raw scores for each class. labels (torch.LongTensor, shape (B?, N)): ground truth labels. Returns: Confusion matrix for current batch. \"\"\" C = scores.size(-1) y_pred = scores.detach().cpu().numpy().reshape(-1, C) # (N, C) y_pred = np.argmax(y_pred, axis=1) # (N,) y_true = labels.detach().cpu().numpy().reshape(-1,) # 此处类似进制，C为类别数。最后对索引计数则可以得到混淆矩阵的扁平化分布 y = np.bincount(C * y_true + y_pred, minlength=C * C) if len(y) \u003c C * C: y = np.concatenate([y, np.zeros((C * C - len(y)), dtype=np.long)]) else: if len(y) \u003e C * C: warnings.warn( \"Prediction has fewer classes than ground truth. This may affect accuracy.\" ) y = y[-(C * C):] # last c*c elements. y = y.reshape(C, C) return y # 计算混淆矩阵 核心代码 def get_confusion_matrix(label_true, label_pred, n_class): mask = (label_true \u003e= 0) \u0026 (label_true \u003c n_class) hist = np.bincount( n_class * label_true[mask].astype(int) + label_pred[mask], minlength=n_class ** 2).reshape(n_class, n_class) return hist 得到acc 与IoU tp = np.longlong(self.confusion_matrix[label, label]) fn = np.longlong(self.confusion_matrix[label, :].sum()) - tp fp = np.longlong(self.confusion_matrix[:, label].sum()) - tp if tp + fp + fn == 0: iou = float('nan') else: iou = (tp) / (tp + fp + fn) if tp + fn == 0: acc = float('nan') else: acc = tp / (tp + fn) ","date":"2022-03-08","objectID":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:0:3","tags":null,"title":"语义分割评价指标","uri":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"}]