[{"categories":["Math"],"content":"形式二：为证明$f(a+b)=f(a)*f(b)$存在唯一实数解$f(x)=a^x$ ","date":"2022-03-16","objectID":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/:0:0","tags":null,"title":"柯西方程与柯西方法","uri":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/"},{"categories":["Math"],"content":"证明 设n为正整数，则 $$ \\begin{aligned} \u0026f(n+1)=f(n)*f(1) \\cr f(n)\u0026=f(n-1)*f(1)\\cr \u0026=f(n-2)*f(1)^2 \\cr \u0026=\\cdots \\cr \u0026=f(1)^n \\end{aligned} $$ 所以 正整数 成立。 由题干性质 $ f(0+0)=f(0)*f(0) $ 可知，$f(0)= 1 \\ or \\ 0$ ，显然为0时，整个函数为0常函数，结论平凡。以下默认$f(0)=1$ . 所以 $$ \\begin{gathered} f(0)=f(n+(-n))=f(n)*f(-n) \\cr f(-n)=f(n)^{-1}=f(1)^{-n} \\end{gathered} $$ 即对 整数 成立。 设n,m为整数 $$ \\begin{aligned} f(n)\u0026=f(\\underbrace { \\frac{1}{n}+\\frac{1}{n}+, \\cdots, + \\frac{1} {n} }_{n^2}) \\cr \u0026=f(\\frac{1}{n})^{n^2} \\end{aligned} $$ 所以 $$ \\begin{aligned} f(\\frac{1}{n})=f(n)^{\\frac{1}{n^2}}=[f(1)^n]^{\\frac{1} {n^2}}=f(1)^{\\frac{1}{n}} \\end{aligned} $$ 则 $$ \\begin{aligned} f(\\frac{m}{n})=f(\\underbrace { \\frac{1}{n} + \\frac{1}{n} + ,\\cdots , + \\frac{1}{n} }_{m})=f(\\frac{1}{n})^m=f(1)^{\\frac{m}{n}} \\end{aligned} $$ 任意有理数可表示为$\\frac{m}{n}$ 的形式，可知结果对 有理数 成立。 如满足下列条件其一 f 连续； f 在一个区间上单调； f 在一个区间上有上界或下界。 易证以上结论在 实数域 上成立。 ","date":"2022-03-16","objectID":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/:0:1","tags":null,"title":"柯西方程与柯西方法","uri":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/"},{"categories":["Math"],"content":"结论 综上，$f(a+b)=f(a)*f(b)$存在唯一实数解$f(x)=a^x$ 参考：https://zhuanlan.zhihu.com/p/80543711 $$ \\begin{aligned} –1– \\end{aligned} $$ ","date":"2022-03-16","objectID":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/:0:2","tags":null,"title":"柯西方程与柯西方法","uri":"/%E6%9F%AF%E8%A5%BF%E6%96%B9%E7%A8%8B%E4%B8%8E%E6%9F%AF%E8%A5%BF%E6%96%B9%E6%B3%95/"},{"categories":[],"content":"aligned, array, gathered, matrix中使用 “\\cr” https://zhuanlan.zhihu.com/p/168773798 ","date":"2022-03-09","objectID":"/loveit%E5%B5%8C%E5%85%A5katex/:0:0","tags":null,"title":"KaTeX在LoveIt中的使用","uri":"/loveit%E5%B5%8C%E5%85%A5katex/"},{"categories":["Math"],"content":"协方差矩阵对角化 设一点集 $$ D= \\left[\\begin{matrix} x_1,y_1 \\cr x_2,y_2\\cr …\\cr x_n,y_n \\end{matrix}\\right]^T $$ 协方差公式为： $$ \\begin{aligned} cov(x,y)=\\frac{ \\sum_i^n{(x_i-\\bar x)(y_i-\\bar y)}}{n-1} \\end{aligned} $$ 去中心化后$\\bar x,\\bar y$为0，（1）式可化为 $$ \\begin{gathered} cov(x,y)=\\frac{ \\sum_i^n{x_iy_i}}{n-1} \\end{gathered} $$ 协方差矩阵为 $$ C = \\left(\\begin{matrix} cov(x,x)\u0026cov(x,y)\\cr cov(y,x)\u0026cov(y,y) \\end{matrix}\\right) $$ $$C = \\frac{1}{n-1}\\cdot DD^T$$ $D$为原始数据分布，$D_s$为 PCA 后其对应的分布，则存在旋转（R）、拉伸（S）矩阵，使得$D=RSD_s$,其中 $$ R=\\left(\\begin{matrix} cos(\\theta)\u0026-sin(\\theta) \\cr sin(\\theta)\u0026cos(\\theta) \\end{matrix}\\right), S=\\left(\\begin{matrix} a\u0026\\cr \u0026b \\end{matrix}\\right) $$ 所以 $$ \\begin{aligned} C^`\u0026=\\frac{1}{n-1} \\cdot DD^{T}= \\frac{1}{n-1}\\cdot RSD_s \\cdot (RSD_s)^T \\cr \u0026=RS\\cdot (\\frac{1}{n-1}D_sD_s^T)\\cdot S^TR^T \\cr \u0026=RSC_sS^TR^T=RSS^TR^T \\cr \u0026=RLR^T \\cr \\end{aligned} $$ 其中 $$ R= \\left( \\begin{matrix} cos(\\theta) \u0026 -sin(\\theta) \\cr sin(\\theta) \u0026 cos(\\theta) \\end{matrix} \\right), L= \\left(\\begin{matrix} a^2 \u0026 \\cr \u0026 b^2 \\end{matrix}\\right) $$ 可见L矩阵为对角阵，R矩阵为正交矩阵$R\\cdot R^T=E$,求R与L相当于对 协方差矩阵对角化。 import numpy as np data = np.random.rand(10,2) #二维点集 n*d cov = np.cov(data.T) #d*d w, v = np.linalg.eig(cov) #此处对特征向量做了单位化，即列向量模长为1 #cov = v@np.diag(w)@v.T indiex = np.argsort(-w) v = v[:,indiex] w = w[indiex] 正交化证明1 $$ \\begin{aligned} MM^T \u0026= v * w * v^{-1} \\cr MM^T \u0026= v^{-T} * w * v^T \\cr v^{-T} * w * v^T \u0026= v * w * v^{-1} \\cr w * v^T * v \u0026= v^T * v * w \\cr w * N \u0026= N * w \\cr a * N[:,0] \u0026= N[0,:] * a \\cr \\end{aligned} $$ 所以N只有对角元素上有值，即特征向量两两正交。但v不一定是酉矩阵，因为没做单位化。而numpy的算法做了单位化处理，具有特异性。 正交化证明2 n维实对称矩阵S，用$\\lambda ,\\alpha$表示其两个不等的特征值，用$x,y$分别表示其对应的特征向量。$S=S^T,Sx=\\lambda x,Sy=\\alpha y(\\alpha \\neq \\lambda)$. 对$Sx=\\lambda x$两边转置右端乘$y$ $$ \\begin{aligned} x^TS^T \u0026= \\lambda x^T\\cr x^TS \u0026= \\lambda x^T\\cr x^TSy \u0026= \\lambda x^Ty \\end{aligned} $$ 对$Sy=\\alpha y$两段左乘$x^T$ $$x^TSy=x^T\\alpha y=\\alpha x^Ty$$ 所以 $$ \\begin{aligned} \\alpha x^Ty \u0026=\\lambda x^Ty \\cr 0 \u0026=(\\alpha-\\lambda)x^Ty \\end{aligned} $$ 已知$\\alpha \\neq \\lambda$,所以$x^Ty=0$,即不同特征值的特征向量两两正交. ","date":"2022-03-09","objectID":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/:0:1","tags":null,"title":"主成分分析","uri":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":["Math"],"content":"PCA投影 维度，k为特征值占比85%的索引数 $D^T: n * d, C: d * d, v: d * d, u: d * k$（v是特征向量矩阵，u包含了特征向量对应特征值占比为前85%的列索引） 投影，$u$的每一列是单位化后的方向向量$|u_{*j}|=1$，点积相当于cos投影： 对D任意一行与u任意一列： $$ \\vec D^T_{i*} \\cdot \\vec u_{j}=|D^T_{i}|\\cdot |u_{j}| \\cdot cos(\\theta)=|D^T_{i}|\\cdot cos(\\theta)(投影值) $$ $D^T \\cdot u:n*k$ $s^2=\\frac{\\sum x_i^2}{n-1}=\\frac{u^TDD^Tu}{n-1}=u^TCu=\\lambda$ 证明如公式3，PCA后的方差是矩阵特征值。方差越大，数据含有的信息越多，数据信号越强 k = 1 Q = v[:,:k] data_norm = data - data.mean(0) # normalization Y = np.matmul(data_norm,Q) #n*d @ d*k = n*k data_ = np.matmul(Y,Q.T)+data.mean(0) # n*k @ k*d = n * d # plt.scatter(data_[:,0],data_[:,1]) ","date":"2022-03-09","objectID":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/:0:2","tags":null,"title":"主成分分析","uri":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":["Math"],"content":"OBB包围盒 todo ","date":"2022-03-09","objectID":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/:0:3","tags":null,"title":"主成分分析","uri":"/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"},{"categories":null,"content":"引言 语义分割是像素级别的分类，其常用评价指标： 像素准确率（Pixel Accuracy，PA）、 类别像素准确率（Class Pixel Accuray，CPA）、 类别平均像素准确率（Mean Pixel Accuracy，MPA）、 交并比（Intersection over Union，IoU）、 平均交并比（Mean Intersection over Union，MIoU）， 其计算都是建立在混淆矩阵（Confusion Matrix）的基础上。因此，了解基本的混淆矩阵知识对理解上述5个常用评价指标是很有益处的！ ","date":"2022-03-08","objectID":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:0:1","tags":null,"title":"语义分割评价指标","uri":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"},{"categories":null,"content":"评价指标 PA：像素准确率 对应：准确率（Accuracy） 含义：预测类别正确的像素数占总像素数的比例 混淆矩阵计算： 对角线元素之和 / 矩阵所有元素之和 PA = (TP + TN) / (TP + TN + FP + FN) CPA：类别像素准确率 对应：精准率（Precision） 含义：在类别 i 的预测值中，真实属于 i 类的像素准确率，换言之：模型对类别 i 的预测值有很多，其中有对有错，预测对的值占预测总值的比例 混淆矩阵计算： 类1：P1 = TP / (TP + FP) 类2：P2 = TN / (TN + FN) 类3：… MPA：类别平均像素准确率 含义：分别计算每个类被正确分类像素数的比例，即：CPA，然后累加求平均 混淆矩阵计算： 每个类别像素准确率为：Pi（计算：对角线值 / 对应列的像素总数） MPA = sum(Pi) / 类别数 IoU：交并比 含义：模型对某一类别预测结果和真实值的交集与并集的比值 混淆矩阵计算： 以求二分类：正例（类别1）的IoU为例 交集：TP，并集：TP、FP、FN求和 IoU = TP / (TP + FP + FN) MIoU：平均交并比 含义：模型对每一类预测的结果和真实值的交集与并集的比值，求和再平均的结果 混淆矩阵计算： 以求二分类的MIoU为例 MIoU = (IoU正例p + IoU反例n) / 2 = [ TP / (TP + FP + FN) + TN / (TN + FN + FP) ] / 2 ","date":"2022-03-08","objectID":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:0:2","tags":null,"title":"语义分割评价指标","uri":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"},{"categories":null,"content":"数值计算 计算混淆矩阵 def get_confusion_matrix(scores, labels): \"\"\"Computes the confusion matrix of one batch Args: scores (torch.FloatTensor, shape (B?, N, C): raw scores for each class. labels (torch.LongTensor, shape (B?, N)): ground truth labels. Returns: Confusion matrix for current batch. \"\"\" C = scores.size(-1) y_pred = scores.detach().cpu().numpy().reshape(-1, C) # (N, C) y_pred = np.argmax(y_pred, axis=1) # (N,) y_true = labels.detach().cpu().numpy().reshape(-1,) # 此处类似进制，C为类别数。最后对索引计数则可以得到混淆矩阵的扁平化分布 y = np.bincount(C * y_true + y_pred, minlength=C * C) if len(y) \u003c C * C: y = np.concatenate([y, np.zeros((C * C - len(y)), dtype=np.long)]) else: if len(y) \u003e C * C: warnings.warn( \"Prediction has fewer classes than ground truth. This may affect accuracy.\" ) y = y[-(C * C):] # last c*c elements. y = y.reshape(C, C) return y # 计算混淆矩阵 核心代码 def get_confusion_matrix(label_true, label_pred, n_class): mask = (label_true \u003e= 0) \u0026 (label_true \u003c n_class) hist = np.bincount( n_class * label_true[mask].astype(int) + label_pred[mask], minlength=n_class ** 2).reshape(n_class, n_class) return hist 得到acc 与IoU tp = np.longlong(self.confusion_matrix[label, label]) fn = np.longlong(self.confusion_matrix[label, :].sum()) - tp fp = np.longlong(self.confusion_matrix[:, label].sum()) - tp if tp + fp + fn == 0: iou = float('nan') else: iou = (tp) / (tp + fp + fn) if tp + fn == 0: acc = float('nan') else: acc = tp / (tp + fn) ","date":"2022-03-08","objectID":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/:0:3","tags":null,"title":"语义分割评价指标","uri":"/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"}]